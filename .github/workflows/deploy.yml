name: Complete CI/CD Pipeline - Deploy to Server

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Code Quality Checks
  code-quality:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black pylint

      - name: Run Flake8 linting
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        continue-on-error: true

      - name: Check code formatting with Black
        run: |
          black --check . --diff
        continue-on-error: true

      - name: Run Pylint
        run: |
          find . -name "*.py" -path "*/migrations" -prune -o -type f -name "*.py" -exec pylint {} +
        continue-on-error: true

  # Job 2: Run Tests
  test:
    needs: code-quality
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: test_db
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run migrations
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db
          DEBUG: False
        run: |
          python manage.py migrate

      - name: Run tests with coverage
        env:
          DATABASE_URL: postgresql://test_user:test_password@localhost:5432/test_db
          DEBUG: False
        run: |
          pip install coverage
          coverage run --source='.' manage.py test --verbosity=2
          coverage report
          coverage xml

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
        continue-on-error: true

  # Job 3: Security Scanning
  security-scan:
    needs: code-quality
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install security tools
        run: |
          pip install bandit safety

      - name: Run Bandit security check
        run: |
          bandit -r . -f json -o bandit-report.json
        continue-on-error: true

      - name: Check for vulnerable dependencies
        run: |
          pip install -r requirements.txt
          safety check --json
        continue-on-error: true

  # Job 4: Build Docker Image
  build:
    needs: [test, security-scan]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Job 4b: Deploy via Self-Hosted Runner (no SSH)
  deploy-self-hosted:
    needs: build
    runs-on: [self-hosted, linux, x64]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Bootstrap host (Docker, Compose, Firewall)
        shell: bash
        run: |
          set -euo pipefail
          if command -v docker >/dev/null 2>&1; then
            echo "Docker is already installed"
          else
            echo "Installing Docker using get.docker.com script"
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
          fi
          if id -nG "$USER" | tr ' ' '\n' | grep -qx "docker"; then
            echo "User $USER already in docker group"
          else
            echo "Adding $USER to docker group"
            sudo usermod -aG docker "$USER" || true
          fi
          if systemctl --version >/dev/null 2>&1; then
            sudo systemctl enable --now docker || true
          fi
          if docker compose version >/dev/null 2>&1; then
            echo "Docker Compose plugin available"
          elif command -v docker-compose >/dev/null 2>&1; then
            echo "docker-compose (standalone) available"
          else
            if command -v apt-get >/dev/null 2>&1; then
              echo "Installing docker-compose-plugin via apt"
              sudo apt-get update -y
              sudo apt-get install -y docker-compose-plugin || true
            fi
            if ! docker compose version >/dev/null 2>&1 && ! command -v docker-compose >/dev/null 2>&1; then
              echo "Installing docker-compose standalone binary"
              ARCH="$(uname -m)"
              OS="$(uname -s)"
              URL="https://github.com/docker/compose/releases/latest/download/docker-compose-${OS}-${ARCH}"
              sudo curl -L "$URL" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
          fi
          if command -v ufw >/dev/null 2>&1; then
            echo "Configuring ufw rules (if ufw active)"
            if sudo ufw status | grep -qi active; then
              sudo ufw allow 80/tcp || true
              sudo ufw allow 443/tcp || true
              sudo ufw allow 8000/tcp || true
            fi
          elif command -v firewall-cmd >/dev/null 2>&1; then
            echo "Configuring firewalld rules"
            sudo firewall-cmd --permanent --add-service=http || true
            sudo firewall-cmd --permanent --add-service=https || true
            sudo firewall-cmd --permanent --add-port=8000/tcp || true
            sudo firewall-cmd --reload || true
          else
            echo "No known firewall tool detected; skipping firewall configuration"
          fi

      - name: Compose build and up
        shell: bash
        run: |
          set -e
          SUDO=""
          if docker info >/dev/null 2>&1; then
            SUDO=""
          elif sudo -n docker info >/dev/null 2>&1; then
            SUDO="sudo"
          else
            echo "Docker daemon not accessible; attempting with sudo"
            SUDO="sudo"
          fi
          if docker compose version >/dev/null 2>&1; then
            COMPOSE_CMD="$SUDO docker compose"
          elif command -v docker-compose >/dev/null 2>&1; then
            COMPOSE_CMD="$SUDO docker-compose"
          else
            echo "docker compose or docker-compose not found after bootstrap"
            exit 1
          fi
          $COMPOSE_CMD build
          $COMPOSE_CMD up -d
          $COMPOSE_CMD ps

      - name: Health check
        shell: bash
        run: |
          set -e
          if curl -fsS http://localhost/api/products/products/ > /dev/null 2>&1; then
            echo "API OK via nginx (port 80)"
          elif curl -fsS http://localhost:8000/api/products/products/ > /dev/null 2>&1; then
            echo "API OK via web (port 8000)"
          else
            echo "API health check failed"
            exit 1
          fi

  # Job 5: Setup Server (First deployment only)
  setup-server:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.DEPLOY_VIA_SSH == 'true'
    
    steps:
      - name: Setup server with Docker
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          debug: true
          script: |
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              newgrp docker
            fi
            
            # Check if Docker Compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Create project directory
            sudo mkdir -p ${{ secrets.PROJECT_PATH }}
            sudo chown -R $USER:$USER ${{ secrets.PROJECT_PATH }}
            
            # Create necessary subdirectories
            mkdir -p ${{ secrets.PROJECT_PATH }}/ssl
            mkdir -p ${{ secrets.PROJECT_PATH }}/.github/workflows
            
            echo "‚úÖ Server setup completed!"
            docker --version
            docker-compose --version

  # Job 6: Database Backup Before Deployment
  backup-database:
    needs: setup-server
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.DEPLOY_VIA_SSH == 'true'
    
    steps:
      - name: Backup production database
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          debug: true
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            
            # Check if container exists
            if docker ps -a --format '{{.Names}}' | grep -q '^ecommerce_db$'; then
              echo "Backing up database..."
              BACKUP_FILE="backups/backup_$(date +%Y%m%d_%H%M%S).sql"
              mkdir -p backups
              
              docker-compose exec -T db pg_dump -U postgres ecommerce_db > $BACKUP_FILE
              
              # Keep only last 10 backups
              ls -1t backups/backup_*.sql | tail -n +11 | xargs -r rm
              
              echo "‚úÖ Database backed up to $BACKUP_FILE"
            else
              echo "‚ö†Ô∏è  Database container not found. Skipping backup."
            fi

  # Job 7: Deploy to Server
  deploy:
    needs: backup-database
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.DEPLOY_VIA_SSH == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Derive CI SSH key fingerprint
        shell: bash
        run: |
          set -euo pipefail
          echo "${{ secrets.SERVER_SSH_KEY }}" > ci_key
          chmod 600 ci_key
          ssh-keygen -y -f ci_key > ci_key.pub
          echo "Key type: $(awk '{print $1}' ci_key.pub)"
          echo "Key fingerprint:"
          ssh-keygen -lf ci_key.pub

      - name: OpenSSH preflight (publickey only)
        shell: bash
        continue-on-error: true
        run: |
          set -x
          echo "${{ secrets.SERVER_SSH_KEY }}" > ci_key
          chmod 600 ci_key
          ssh -vvv -o StrictHostKeyChecking=no -o PreferredAuthentications=publickey -p "${{ secrets.SERVER_PORT }}" -i ci_key "${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}" "echo ok"

      - name: SSH preflight
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          # Try password first to bypass key issues if server allows it
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          use_insecure_cipher: true
          debug: true
          script_stop: true
          script: |
            echo "Connected to $(hostname) as $(whoami)"
            date
      
      - name: SSH preflight (key-based)
        uses: appleboy/ssh-action@master
        continue-on-error: true
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT }}
          debug: true
          script: |
            echo "Key-based preflight successful on $(hostname)"

      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          debug: true
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            
            echo "üöÄ Starting deployment..."
            
            # Save current container state for rollback
            docker-compose ps > /tmp/docker_state_before.txt
            
            # Pull latest code
            echo "üì• Pulling latest code..."
            git pull origin main || { echo "‚ùå Git pull failed"; exit 1; }
            
            # Pull latest Docker image
            echo "üê≥ Pulling Docker image..."
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main || { echo "‚ùå Docker pull failed"; exit 1; }
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              cp .env.example .env
              echo "‚ö†Ô∏è  Created .env from template. Please update with production values!"
            fi
            
            # Stop old containers
            echo "üõë Stopping old containers..."
            docker-compose down
            
            # Start new containers
            echo "‚ö° Starting new containers..."
            docker-compose up -d || { echo "‚ùå Container startup failed"; exit 1; }
            
            # Wait for database to be ready
            echo "‚è≥ Waiting for database to be ready..."
            sleep 10
            
            # Run migrations
            echo "üîÑ Running migrations..."
            docker-compose exec -T web python manage.py migrate || { 
              echo "‚ùå Migrations failed! Rolling back..."
              docker-compose down
              exit 1
            }
            
            # Collect static files
            echo "üì¶ Collecting static files..."
            docker-compose exec -T web python manage.py collectstatic --noinput || {
              echo "‚ö†Ô∏è  Static file collection failed (non-critical)"
            }
            
            # Restart services to apply changes
            echo "üîÉ Restarting services..."
            docker-compose restart web nginx
            
            # Clear old logs
            docker system prune -f
            
            echo "‚úÖ Deployment completed successfully!"
            docker-compose ps

      - name: Notify deployment success
        if: success()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": "‚úÖ Deployment Successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚úÖ Deployment Successful*\n*Repo:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}"
                  }
                }
              ]
            }
        continue-on-error: true

      - name: Notify deployment failure
        if: failure()
        uses: slackapi/slack-github-action@v1.24.0
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": "‚ùå Deployment Failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚ùå Deployment Failed*\n*Repo:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Author:* ${{ github.actor }}\n*Check logs:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }
        continue-on-error: true

  # Job 8: Health Check
  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.DEPLOY_VIA_SSH == 'true'
    
    steps:
      - name: Wait for deployment
        run: sleep 15

      - name: Check API health
        run: |
          echo "üè• Checking API health..."
          for i in {1..5}; do
            if curl -f http://${{ secrets.SERVER_HOST }}/api/products/products/ > /dev/null 2>&1; then
              echo "‚úÖ API is healthy!"
              exit 0
            fi
            echo "‚è≥ Attempt $i/5 - Waiting for API to be ready..."
            sleep 10
          done
          echo "‚ùå API health check failed after 5 attempts"
          exit 1

      - name: Check admin panel
        run: |
          echo "üîç Checking admin panel..."
          curl -f http://${{ secrets.SERVER_HOST }}/admin/ > /dev/null 2>&1 && echo "‚úÖ Admin panel is accessible"
        continue-on-error: true

      - name: Verify migrations completed
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            echo "üîç Verifying migrations..."
            docker-compose exec -T web python manage.py showmigrations | head -20
            echo "‚úÖ Migrations verified"

      - name: Notify health check success
        if: success()
        run: echo "‚úÖ All health checks passed!"

      - name: Rollback on health check failure
        if: failure()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            echo "‚ö†Ô∏è  Health check failed! Rolling back..."
            
            # Get the previous commit
            PREVIOUS_COMMIT=$(git log --oneline -2 | tail -1 | awk '{print $1}')
            
            echo "üîÑ Rolling back to commit: $PREVIOUS_COMMIT"
            git reset --hard $PREVIOUS_COMMIT
            
            # Restart containers with previous code
            docker-compose down
            docker-compose up -d
            docker-compose exec -T web python manage.py migrate
            docker-compose restart web nginx
            
            echo "‚úÖ Rollback completed!"

  # Job 9: Post-Deployment Checks
  post-deployment:
    needs: health-check
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && vars.DEPLOY_VIA_SSH == 'true'
    
    steps:
      - name: Check container logs
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            echo "üìã Recent application logs:"
            docker-compose logs --tail=20 web
            echo ""
            echo "üìã Recent nginx logs:"
            docker-compose logs --tail=20 nginx

      - name: Verify database connectivity
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            echo "üîç Verifying database connectivity..."
            docker-compose exec -T db psql -U postgres -d ecommerce_db -c "SELECT NOW();" || {
              echo "‚ùå Database connectivity check failed"
              exit 1
            }
            echo "‚úÖ Database is connected and working"

      - name: Check SSL certificate validity
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            if [ -f ssl/cert.pem ]; then
              echo "üîí SSL Certificate details:"
              openssl x509 -in ssl/cert.pem -text -noout | grep -E "Subject:|Issuer:|Not Before|Not After"
            fi

      - name: Generate deployment report
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          password: ${{ secrets.SERVER_PASSWORD }}
          port: ${{ secrets.SERVER_PORT }}
          script: |
            cd ${{ secrets.PROJECT_PATH }}
            echo "üìä Deployment Report"
            echo "===================="
            echo "Timestamp: $(date)"
            echo "Git Commit: $(git rev-parse HEAD)"
            echo "Git Branch: $(git rev-parse --abbrev-ref HEAD)"
            echo ""
            echo "Running Containers:"
            docker-compose ps
            echo ""
            echo "Docker Images:"
            docker images | grep ecommerce
            echo ""
            echo "Disk Usage:"
            du -sh .
            echo ""
            echo "‚úÖ Deployment Report Generated"

      - name: Send final notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          webhook-url: ${{ secrets.SLACK_WEBHOOK }}
          payload: |
            {
              "text": "‚úÖ Complete Deployment Cycle Finished",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*‚úÖ Deployment Cycle Complete*\n‚úì Tests Passed\n‚úì Built Docker Image\n‚úì Database Backed Up\n‚úì Deployed to Server\n‚úì Migrations Applied\n‚úì Health Checks Passed\n‚úì Post-Deployment Checks Passed"
                  }
                }
              ]
            }
        continue-on-error: true
